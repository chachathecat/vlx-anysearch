<!DOCTYPE html>
<html lang="en">
<meta charset="utf-8" />
<title>Visual Lexicon – Mini</title>

<style>
  :root{ --vlx-accent:#111; --vlx-blue1:#2A6EF2; --vlx-blue2:#6B8CFF; --vlx-muted:#666; --vlx-border:#e9e9ee; --vlx-bg:#fafafa; --vlx-chip:#f5f6f8; --vlx-radius:16px; --vlx-shadow:0 6px 18px rgba(0,0,0,.06); }

  .vlx-wrap{max-width:860px;margin:0 auto;padding:16px}

  /* 상단 검색 바: 한 번만 선언 + 항상 위로 */
  .vlx-row{
    display:flex;
    gap:10px;
    align-items:center;
    flex-wrap:wrap;
    position:sticky;
    top:0;
    z-index:2000;
    background:#fff;
    padding:8px;
    border-radius:14px;
    box-shadow:var(--vlx-shadow);
  }

  .vlx-input-wrap{position:relative;flex:1;min-width:260px}
  .vlx-input{
    flex:1;
    width:100%;
    padding:14px 16px;
    border:1px solid var(--vlx-border);
    border-radius:14px;
    font-size:16px;
    background:#fff;
    min-height:44px;
  }

  .vlx-btn{padding:12px 16px;border:0;border-radius:14px;color:#fff;cursor:pointer;font-weight:600;background:linear-gradient(135deg,var(--vlx-blue1),var(--vlx-blue2));box-shadow:var(--vlx-shadow);height:44px;display:inline-flex;align-items:center}
  .vlx-btn2{padding:12px 14px;border-radius:14px;border:1px solid var(--vlx-border);background:#fff;color:#111;font-weight:600;cursor:pointer;box-shadow:var(--vlx-shadow);height:44px;display:inline-flex;align-items:center}
  .vlx-btn2.active{border-color:var(--vlx-blue1);color:var(--vlx-blue1)}

  .vlx-status{margin:10px 2px;color:var(--vlx-muted);font-size:14px}

  /* 카드가 툴바보다 아래 레이어로 */
  .vlx-card{
    display:none;
    position:relative;
    z-index:100;
    margin-top:12px;
    border:1px solid var(--vlx-border);
    border-radius:var(--vlx-radius);
    padding:18px;
    background:#fff;
    box-shadow:var(--vlx-shadow);
  }

  .vlx-head{display:flex;align-items:center;gap:12px;flex-wrap:wrap}
  .vlx-head h2{margin:0;font-size:22px}
  .vlx-ipa{color:var(--vlx-muted)}
  .vlx-section{margin-top:12px}
  .vlx-col2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  .vlx-chip{display:inline-block;background:var(--vlx-chip);border-radius:999px;padding:4px 10px;margin:2px;font-size:13px}
  .vlx-small{color:var(--vlx-muted);font-size:14px;line-height:1.55}
  .vlx-list{margin:6px 0 0 0;padding-left:18px}

  .vlx-imggrid{display:grid;grid-template-columns:repeat(auto-fit, minmax(120px, 1fr));gap:12px;margin-top:8px}
  .vlx-imgbox{aspect-ratio:1/1;width:100%;border-radius:12px;overflow:hidden;background:var(--vlx-bg);border:1px solid var(--vlx-border);position:relative}
  .vlx-imgbox img{width:100%;height:100%;object-fit:contain;object-position:center;display:block}
  .vlx-caption{color:#888;font-size:12px;margin-top:6px}

  .vlx-spin{display:none;width:18px;height:18px;border:2px solid #ddd;border-top-color:var(--vlx-blue1);border-radius:50%;animation:vlx-rot .9s linear infinite}
  @keyframes vlx-rot{to{transform:rotate(360deg)}}

  @media (max-width:720px){ .vlx-imggrid{ grid-template-columns:repeat(auto-fit, minmax(100px, 1fr)) } }
  @media (max-width:420px){
    .vlx-imggrid{ grid-template-columns:repeat(2, 1fr) }
    .vlx-imggrid>.vlx-imgbox:last-child:nth-child(odd){ grid-column:1/-1;justify-self:center;max-width:260px;width:100% }
  }

  /* 자동완성 드롭다운이 모든 것 위에 */
  .vlx-suggest{
    position:absolute;
    top:100%; left:0; right:0;
    margin-top:6px;
    background:#fff;
    border:1px solid var(--vlx-border);
    border-radius:12px;
    box-shadow:var(--vlx-shadow);
    max-height:260px;
    overflow:auto;
    z-index:3000;
    display:none;
  }
  .vlx-suggest ul{list-style:none;margin:0;padding:6px}
  .vlx-suggest li{padding:10px 12px;cursor:pointer;border-radius:8px;display:flex;justify-content:space-between;gap:10px}
  .vlx-suggest li:hover,.vlx-suggest li.active{background:var(--vlx-chip)}
  .vlx-sug-roman{color:#999;font-size:12px;white-space:nowrap}

  .vlx-langbar{display:flex;flex-wrap:wrap;gap:6px;margin:6px 0 10px}
  .vlx-langbtn{padding:6px 10px;border-radius:999px;border:1px solid var(--vlx-border);background:#fff;cursor:pointer;font-size:12px}
  .vlx-langbtn.active{background:var(--vlx-blue2);color:#fff;border-color:transparent}
  .vlx-transbox{border:1px solid var(--vlx-border);border-radius:12px;padding:10px;background:#fff}

  .vlx-3d{border:1px solid var(--vlx-border);border-radius:12px;background:#fafafa;height:360px;min-height:320px;overflow:hidden;position:relative;z-index:1}
  .vlx-3d::before{content:"";position:absolute;inset:0;background:linear-gradient(90deg,#0b0f17,#101726,#0b0f17);background-size:200% 100%;animation:vlx-shimmer 1.6s linear infinite;opacity:0;transition:opacity .25s ease}
  .vlx-status.toast{display:inline-flex;align-items:center;gap:8px;background:#fff;border:1px solid var(--vlx-border);border-radius:10px;padding:8px 10px;box-shadow:var(--vlx-shadow)}
  .vlx-3d.loading::before{opacity:.8}
  @keyframes vlx-shimmer{0%{background-position:200% 0}100%{background-position:-200% 0}}

  .vlx-hintwrap{position:absolute;inset:0;pointer-events:none}
  .vlx-notice{position:absolute;left:12px;bottom:12px;display:flex;align-items:center;gap:10px;background:rgba(15,23,42,.92);color:#e6eefc;border:1px solid rgba(148,163,184,.25);padding:10px 12px;border-radius:12px;box-shadow:0 10px 24px rgba(0,0,0,.25);backdrop-filter:blur(6px);pointer-events:auto;font-size:12px;line-height:1.4}
  .vlx-notice .vlx-dot{width:8px;height:8px;border-radius:999px;background:#f59e0b;box-shadow:0 0 0 2px rgba(245,158,11,.25)}
  .vlx-notice button{border:0;border-radius:999px;padding:6px 10px;background:#2A6EF2;color:#fff;font-weight:600;cursor:pointer}
  .vlx-notice a{color:#9ec1ff;text-decoration:underline}

  .vlx-caption .vlx-tag{display:inline-flex;align-items:center;gap:6px;background:#f5f6f8;color:#475569;border:1px solid var(--vlx-border);padding:3px 8px;border-radius:999px;font-size:12px}
  .vlx-quota{display:none;margin-top:8px}
  .vlx-quota.toast{display:inline-flex;align-items:center;gap:8px;background:#fff;border:1px solid var(--vlx-border);border-radius:10px;padding:8px 10px;box-shadow:var(--vlx-shadow)}
</style>


<div class="vlx-wrap">
  <div class="vlx-row">
    <div class="vlx-input-wrap">
      <input id="vlx-q" class="vlx-input" placeholder="Type any word in ANY language…" autocomplete="off" />
      <div id="vlx-suggest" class="vlx-suggest"></div>
    </div>
    <button id="vlx-go" class="vlx-btn" type="button">Search</button>
    <!-- NEW: toggle button -->
    <button id="vlx-img-toggle" class="vlx-btn2" type="button" aria-pressed="false" title="Toggle image source (Auto → Commons → Default)">Images: Auto</button>
    <div id="vlx-spin" class="vlx-spin"></div>
  </div>

  <div id="vlx-status" class="vlx-status"></div>

  <div id="vlx-card" class="vlx-card">
    <div class="vlx-head">
      <h2 id="vlx-word"></h2>
      <span id="vlx-ipa" class="vlx-ipa"></span>
      <audio id="vlx-audio" controls preload="none" style="display:none;height:32px"></audio>
      <span id="vlx-mode" class="vlx-chip" style="display:none"></span>
      <span id="vlx-ai-pair" class="vlx-chip" style="display:none"></span>
    </div>

    <div class="vlx-section">
      <div id="vlx-imgs" class="vlx-imggrid"></div>
      <div id="vlx-img-caption" class="vlx-caption"></div>
      <div id="vlx-quota" class="vlx-quota toast"></div>
    </div>

    <div class="vlx-section">
      <h4 style="margin:0 0 6px 0">Definitions</h4>
      <div id="vlx-defs"></div>
      <div id="vlx-def-source" class="vlx-caption"></div>
    </div>

    <div class="vlx-section vlx-col2">
      <div>
        <h4 style="margin:0 0 6px 0">Parts of Speech</h4>
        <div id="vlx-pos"></div>
      </div>
      <div>
        <h4 style="margin:0 0 6px 0">Synonyms / Antonyms</h4>
        <div id="vlx-synant"></div>
      </div>
    </div>

    <div class="vlx-section" id="sec-der">
      <h4 style="margin:0 0 6px 0">Derivatives</h4>
      <div id="vlx-der"></div>
    </div>

    <div class="vlx-section" id="sec-ex">
      <h4 style="margin:0 0 6px 0">Examples</h4>
      <div id="vlx-ex"></div>
    </div>

    <div class="vlx-section" id="sec-trans">
      <h4 style="margin:0 0 6px 0">Translate / Target-language Definitions</h4>
      <div id="vlx-trans-lang" class="vlx-langbar"></div>
      <div id="vlx-trans-body" class="vlx-transbox"></div>
    </div>

    <div class="vlx-section" id="sec-3d">
      <h4 style="margin:0 0 6px 0">3D Thesaurus</h4>
      <div id="vlx-3d" class="vlx-3d"><div style="padding:10px;color:#888">Loading 3D graph…</div></div>
    </div>

    <div class="vlx-section">
      <div id="vlx-ai-note" class="vlx-status toast" style="display:none"></div>
    </div>
  </div>
</div>

<script>
  // (Optional) override CDNs – set these BEFORE the script runs.
  window.VLX_3D_THREE_SRC = "https://chachathecat.github.io/vlx-static/vendor/three.min.js";
  window.VLX_3D_FG_SRC    = "https://chachathecat.github.io/vlx-static/vendor/3d-force-graph.min.js";

(function(){
  // ---------- Config ----------
  const API_BASE   = (window.VLX_PROXY && String(window.VLX_PROXY)) || "https://api.visuallexicon.org";
  const AUTH_TOKEN = (window.VLX_TOKEN && String(window.VLX_TOKEN)) || null;
  const KO_STD_KEY = (window.KO_STD_KEY && String(window.KO_STD_KEY)) || localStorage.getItem('KO_STD_KEY') || '';
  const YA_DICT_KEY= (window.YA_DICT_KEY && String(window.YA_DICT_KEY)) || localStorage.getItem('YA_DICT_KEY') || '';
  const DWDS_TOKEN = (window.DWDS_TOKEN && String(window.DWDS_TOKEN)) || localStorage.getItem('DWDS_TOKEN') || '';

  const MAX_IMGS   = 3;
  const SHOW_SUGGESTIONS = true;
  const DEFAULT_IMAGE_POLICY = 'auto'; // 'auto' | 'commons' | 'default'
  const AUTO_SEARCH_ON_INPUT = false;

  const LANG_OPTIONS = [
    { code:"en", label:"English" },{ code:"ko", label:"한국어" },{ code:"ja", label:"日本語" },
    { code:"zh", label:"中文" },{ code:"es", label:"Español" },{ code:"hi", label:"हिन्दी" },
    { code:"fr", label:"Français" },{ code:"ar", label:"اَلْعَرَبِيَّةُ" },{ code:"bn", label:"বাংলা" },
    { code:"ru", label:"русский язык" },{ code:"pt", label:"português" },{ code:"id", label:"Bahasa Indonesia" },
    { code:"de", label:"Deutsch" },{ code:"vi", label:"Tiếng Việt" },{ code:"tr", label:"Türkçe" },{ code:"ur", label:"اردو" }
  ];

  // ---------- Shorthands ----------
  const $ = id => document.getElementById(id);

  // ---- Plan/Quota 안내 문구 (로케일 대응) ----
  const PLAN_URL = 'https://www.visuallexicon.org/subscription';
  function quotaMessage(lang){
    const L = canonLang(lang||'en');
    if (L==='ko') return `AnySearch 이미지 미리보기는 <strong>플랜별 할당량</strong>이 적용됩니다. 사용하려면 <a href="${PLAN_URL}" target="_blank" rel="noopener">구독</a>이 필요합니다.`;
    if (L==='ja') return `AnySearch の画像プレビューにはプランごとの <strong>クォータ</strong>が適用されます。ご利用には<a href="${PLAN_URL}" target="_blank" rel="noopener">サブスクリプション</a>が必要です。`;
    if (L==='zh' || L==='zh-hans') return `AnySearch 图片预览受 <strong>套餐配额</strong>限制。使用需<a href="${PLAN_URL}" target="_blank" rel="noopener">订阅</a>。`;
    if (L==='zh-hant') return `AnySearch 圖片預覽受 <strong>方案額度</strong>限制。使用需<a href="${PLAN_URL}" target="_blank" rel="noopener">訂閱</a>。`;
    return `AnySearch image previews are subject to plan quotas. A <a href="${PLAN_URL}" target="_blank" rel="noopener">subscription</a> is required.`;
  }

  const statusEl=$('vlx-status'), cardEl=$('vlx-card'), spinEl=$('vlx-spin');
  const qEl=$('vlx-q'), goEl=$('vlx-go'), sugEl=$('vlx-suggest');
  const imgToggle=$('vlx-img-toggle');

  const small = s => `<div class="vlx-small">${s}</div>`;
  const chip  = s => `<span class="vlx-chip">${s}</span>`;
  const li    = s => `<li>${s}</li>`;
  const esc   = s => (s||'').replace(/[&<>]/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[m]));
  const uniq  = a => Array.from(new Set((a||[]).filter(Boolean)));
  const debounce=(fn,ms=400)=>{let t;return(...a)=>{clearTimeout(t);t=setTimeout(()=>fn(...a),ms);};};

  // ---------- Fetch helpers ----------
  const join=(b,p)=> (b.endsWith('/')?b.slice(0,-1):b) + (p.startsWith('/')?p:('/'+p));
  const urlOf= p => { const s=join(API_BASE,p); try{ return new URL(s, location.origin).toString(); }catch{ return s; } };

  function sameSiteAsPage(apiBase){
    try{
      const api=new URL(apiBase, location.href);
      const registrable = h => h.split('.').slice(-2).join('.');
      return api.protocol===location.protocol && registrable(api.hostname)===registrable(location.hostname);
    }catch{ return true; }
  }
  const SEND_COOKIES = sameSiteAsPage(API_BASE) && !AUTH_TOKEN;

  async function j(url, lang){
    const headers = { 'Accept-Language': lang || 'en' };
    if (AUTH_TOKEN) headers['Authorization'] = `Bearer ${AUTH_TOKEN}`;
    const ctrl=new AbortController(); const to=setTimeout(()=>ctrl.abort(),12000);
    try{
      const res=await fetch(url,{ method:'GET', mode:'cors', cache:'no-store',
        credentials: SEND_COOKIES?'include':'omit', headers, signal:ctrl.signal });
      if(res.status===401) throw new Error('login-required');
      if(!res.ok){ const txt=await res.text().catch(()=> ''); throw new Error(`HTTP ${res.status} ${res.statusText} — ${txt.slice(0,160)}`); }
      return await res.json();
    }catch(err){
      const msg=String(err?.message||err);
      statusEl.innerHTML = (msg==='login-required')
        ? 'Please <a href="/login" style="text-decoration:underline">log in</a> to use the inline dictionary.'
        : `API error: ${esc(msg)}`;
      return null;
    }finally{ clearTimeout(to); }
  }

  // ---------- Lang / utils ----------
  function guessLang(t){
    if(/[가-힣]/.test(t)) return 'ko';
    if(/[ぁ-ゔァ-ヴー々〆〤]/.test(t)) return 'ja';
    if(/[一-龥]/.test(t)) return 'zh';
    if(/[А-Яа-яЁё]/.test(t)) return 'ru';
    if(/[à-ÿ]/i.test(t)) return 'fr';
    if(/[ñáéíóúü]/i.test(t)) return 'es';
    if(/çi|ção|ções|ão|ões/i.test(t)) return 'pt';
    if(/[ğüşöçıİ]/i.test(t)) return 'tr';
    if(/[äöüß]/i.test(t)) return 'de';
    if(/[a-zA-Z]/.test(t)) return 'en';
    return 'en';
  }
  const canonLang = l => ({kr:'ko',jp:'ja',cn:'zh',tw:'zh-hant','zh-cn':'zh','zh-tw':'zh-hant',hk:'zh-hant'}[(l||'').toLowerCase()] || (l||'').toLowerCase() || 'en');
  function getUiLang(fallback){
    const bar = document.getElementById('vlx-trans-lang');
    const active = bar?.querySelector('[data-lang].is-active,[data-lang].active');
    if (active?.dataset?.lang) return canonLang(active.dataset.lang);
    const docLang = document.documentElement.getAttribute('lang');
    if (docLang) return canonLang(docLang);
    const navLang = navigator.language || navigator.userLanguage;
    if (navLang) return canonLang(navLang);
    return canonLang(guessLang(fallback || ''));
  }

  // ---------- AnySearch: images / graph ----------
  function getVLImages(word, opts={}){
    const u=new URL(urlOf(''));
    u.searchParams.set('lemma', word.trim().toLowerCase());
    u.searchParams.set('lang', getUiLang(word));
    if(opts.source) u.searchParams.set('source', String(opts.source));
    return j(u.toString(), getUiLang(word));
  }

  // --- MODE TOGGLE (Auto/Commons/Default) ---
  let IMG_MODE = (localStorage.getItem('VLX_IMG_MODE') || DEFAULT_IMAGE_POLICY || 'auto').toLowerCase();
  const humanMode = m => (m==='commons'?'Commons':(m==='default'?'Default':'Auto'));
  function applyModeLabel(){
    if(!imgToggle) return;
    imgToggle.textContent = `Images: ${humanMode(IMG_MODE)}`;
    const active = IMG_MODE !== 'auto';
    imgToggle.classList.toggle('active', active);
    imgToggle.setAttribute('aria-pressed', String(active));
  }
  applyModeLabel();
  imgToggle.addEventListener('click', ()=>{
    IMG_MODE = (IMG_MODE==='auto') ? 'commons' : (IMG_MODE==='commons' ? 'default' : 'auto');
    localStorage.setItem('VLX_IMG_MODE', IMG_MODE);
    applyModeLabel();
    if(qEl.value.trim()) run();
  });

  // Decide image options (button override > URL params > default policy)
  function decideImageOpts(){
    // 1) explicit user toggle wins
    if (IMG_MODE === 'commons') return { source:'commons' };
    if (IMG_MODE === 'default') return {};

    // 2) URL / hash overrides (when in Auto)
    try{
      const sp = new URLSearchParams(location.search);
      const qs = (sp.get('source') || sp.get('mode') || sp.get('policy') || sp.get('img') || '').toLowerCase();
      const bare = sp.has('commons') ? 'commons' : (sp.has('default') ? 'default' : '');
      const hashMatch = (location.hash.match(/(?:^|#)(commons|default)\b/i) || [])[1] ||
                        (location.hash.match(/mode=(commons|default)/i) || [])[1] || '';
      const ov = (qs || bare || hashMatch).toLowerCase();
      if (ov === 'commons') return { source:'commons' };
      if (ov === 'default') return {};
    }catch{}

    // 3) global fallback policy
    if (DEFAULT_IMAGE_POLICY === 'commons') return { source:'commons' };
    if (DEFAULT_IMAGE_POLICY === 'default') return {};
    return {};
  }

  function getVLGraph(word, lemmaLang){
    const lang=canonLang(lemmaLang||'en');
    const u=new URL(urlOf('graph'));
    u.searchParams.set('lemma', word.trim().toLowerCase());
    u.searchParams.set('k','12');
    u.searchParams.set('lang', lang);
    return j(u.toString(), lang);
  }

  const SCORE={KO_STD:0.95,JISHO:0.9,MOE:0.9,DICTAPI:0.85,DWDS:0.8,DA:0.8,TDK:0.85,YANDEX:0.75,WIKI:0.65};
  const TTL={GOOD:86400,OK:43200,WEAK:3600};
  const pack=(ok,defs,src,extra={})=>Object.assign({ok,defs:(defs||[]).filter(Boolean).slice(0,5),source:src,score:0.6,ttlSec:TTL.OK},extra);
  function chooseBetter(a,b){ if(!a) return b; if(!b) return a; if(b.score!==a.score) return b.score>a.score?b:a;
    const r=x=>(x.ipa?1:0)+(x.audio?1:0)+(x.pos?.length?1:0)+(x.examples?.length?1:0)+(x.syn?.length?1:0); return r(b)>r(a)?b:a; }
  const safeCall=fn=>fn().catch(()=>null);
  const readCache=k=>{ try{ const raw=localStorage.getItem(k); if(!raw) return null; const j=JSON.parse(raw);
    if(!j?.exp||Date.now()>j.exp){ localStorage.removeItem(k); return null; } return j.data; }catch{ return null; } };
  const writeCache=(k,v,ttl)=>{ try{ localStorage.setItem(k, JSON.stringify({exp:Date.now()+((ttl||3600)*1000), data:v})); }catch{} };

  // --- Dictionary drivers (unchanged, trimmed for brevity in this comment) ---
  async function dictionaryApiDevDriver(term){
    try{
      const r=await fetch('https://api.dictionaryapi.dev/api/v2/entries/en/'+encodeURIComponent(term));
      if(!r.ok) return null; const j=await r.json();
      const out={ipa:'',ipaAudio:'',pos:new Set(),syn:new Set(),ant:new Set(),examples:[],defs:[]};
      for(const e of j){
        for(const ph of (e.phonetics||[])){ if(!out.ipa&&ph.text) out.ipa=ph.text; if(!out.ipaAudio&&ph.audio) out.ipaAudio=ph.audio; }
        for(const m of (e.meanings||[])){
          if(m.partOfSpeech) out.pos.add(m.partOfSpeech);
          for(const d of (m.definitions||[])){
            if(d.definition) out.defs.push(d.definition);
            if(d.example) out.examples.push(d.example);
            (d.synonyms||[]).forEach(s=>out.syn.add(s));
            (d.antonyms||[]).forEach(s=>out.ant.add(s));
          }
        }
      }
      if(!out.defs.length) return null;
      return pack(true, out.defs, 'dictionaryapi.dev', {
        score:SCORE.DICTAPI, ipa:out.ipa||'', audio:out.ipaAudio||'',
        pos:[...out.pos], examples: out.examples.slice(0,4),
        syn:[...out.syn], ant:[...out.ant], ttlSec: TTL.GOOD
      });
    }catch{ return null; }
  }
  async function koStdDriver(term){
    if(!KO_STD_KEY) return null;
    try{
      const u=`https://stdict.korean.go.kr/api/search.do?key=${encodeURIComponent(KO_STD_KEY)}&q=${encodeURIComponent(term)}&req_type=xml`;
      const r=await fetch(u); if(!r.ok) return null; const txt=await r.text();
      const dom=new DOMParser().parseFromString(txt,'text/xml');
      const first=dom.querySelector('item, channel item'); if(!first) return null;
      let defs=[]; first.querySelectorAll('sense definition').forEach(d=>d.textContent&&defs.push(d.textContent.trim()));
      if(!defs.length){ const d=first.querySelector('definition'); if(d) defs=[d.textContent.trim()]; }
      const pos=Array.from(first.querySelectorAll('pos, part, class')).map(n=>n.textContent.trim()).filter(Boolean);
      if(!defs.length) return null;
      return pack(true, defs.slice(0,5), '국립국어원 표준국어대사전', {score:SCORE.KO_STD,pos,ttlSec:TTL.GOOD});
    }catch{ return null; }
  }
  async function jishoDriver(term){
    try{
      const r=await fetch('https://jisho.org/api/v1/search/words?keyword='+encodeURIComponent(term));
      if(!r.ok) return null; const j=await r.json(); const d=j?.data?.[0]; if(!d) return null;
      const defs=(d.senses||[]).flatMap(s=>s.english_definitions||[]).slice(0,5);
      const pos=(d.senses?.[0]?.parts_of_speech||[]);
      if(!defs.length) return null; return pack(true, defs, 'Jisho.org', {score:SCORE.JISHO,pos,ttlSec:TTL.GOOD});
    }catch{ return null; }
  }
  async function moeDictDriver(term){
    for(const u of [
      `https://www.moedict.tw/uni/${encodeURIComponent(term)}.json`,
      `https://www.moedict.tw/raw/${encodeURIComponent(term)}`
    ]){
      try{
        const r=await fetch(u); if(!r.ok) continue; const j=await r.json();
        const het=(j.heteronyms||[])[0]||{}; const defs=(het.definitions||[]).map(d=>d.def).filter(Boolean).slice(0,5);
        if(defs.length) return pack(true, defs, 'MoeDict', {score:SCORE.MOE,pos:(het?.type?[het.type]:[]),ttlSec:TTL.GOOD});
      }catch{}
    } return null;
  }
  async function dwdsDriver(term){
    try{
      const r=await fetch(`https://www.dwds.de/api/wb/snippet/?q=${encodeURIComponent(term)}`, {headers: DWDS_TOKEN?{Authorization:`Token ${DWDS_TOKEN}`} : undefined});
      if(!r.ok) return null; const j=await r.json(); const it=(j?.items||[])[0];
      const txt=(it?.snippet||'').replace(/<[^>]+>/g,'').trim(); if(!txt) return null;
      return pack(true,[txt],'DWDS',{score:SCORE.DWDS,ttlSec:TTL.OK});
    }catch{ return null; }
  }
  const stripTags=x=>String(x||'').replace(/<[^>]+>/g,'').replace(/\s+/g,' ').trim();
  async function dicionarioAbertoDriver(term){
    try{
      const r=await fetch('https://api.dicionario-aberto.net/word/'+encodeURIComponent(term));
      if(!r.ok) return null; const j=await r.json(); const xml=(j?.[0]?.xml)||''; if(!xml) return null;
      const dom=new DOMParser().parseFromString(xml,'text/xml');
      const defs=Array.from(dom.querySelectorAll('def')).map(n=>stripTags(n.textContent)).filter(Boolean).slice(0,5);
      if(!defs.length) return null; return pack(true, defs, 'Dicionário Aberto', {score:SCORE.DA,ttlSec:TTL.OK});
    }catch{ return null; }
  }
  async function tdkDriver(term){
    try{
      const r=await fetch('https://sozluk.gov.tr/gts?ara='+encodeURIComponent(term));
      if(!r.ok) return null; const j=await r.json();
      const rec=j?.[0]||j?.result?.[0]; if(!rec) return null;
      const defs=(rec.anlamlarListe||[]).map(x=>x.anlam).filter(Boolean).slice(0,5);
      if(!defs.length) return null; return pack(true, defs, 'TDK', {score:SCORE.TDK,ttlSec:TTL.OK});
    }catch{ return null; }
  }
  async function yandexRuDriver(term){
    if(!YA_DICT_KEY) return null;
    try{
      const u=`https://dictionary.yandex.net/api/v1/dicservice.json/lookup?key=${encodeURIComponent(YA_DICT_KEY)}&lang=ru-en&text=${encodeURIComponent(term)}`;
      const r=await fetch(u); if(!r.ok) return null; const j=await r.json();
      const defs=(j?.def?.[0]?.tr||[]).map(t=>t.text).filter(Boolean).slice(0,5);
      if(!defs.length) return null; return pack(true, defs, 'Yandex Dictionary', {score:SCORE.YANDEX,ttlSec:TTL.OK});
    }catch{ return null; }
  }
  const hostFromLang=l=>{ const L=canonLang(l); if(L.startsWith('zh')) return 'zh'; if(L.includes('-')) return L.split('-')[0]; return L||'en'; };
  function wiktionaryDriver(lang){
    const host=hostFromLang(lang);
    return async function(term){
      try{
        const url=`https://${host}.wiktionary.org/w/api.php?action=query&prop=extracts&explaintext=1&redirects=1&format=json&origin=*&titles=${encodeURIComponent(term)}`;
        const r=await fetch(url); if(!r.ok) return null; const j=await r.json();
        const first=Object.values(j?.query?.pages||{})[0]; const ext=first?.extract||""; if(!ext) return null;
        const lines=ext.split("\n").map(s=>s.trim()).filter(Boolean);
        const ignore=/(IPA|Pronunciation|발음|参照|음성|語源|Etymology|^=+.*=+|\b한국어\b|\b日本語\b)/i;
        const pick=lines.find(l=>/^#\s*/.test(l)&&!ignore.test(l))||lines.find(l=>/^[-*•]\s*/.test(l)&&!ignore.test(l))||lines.find(l=>l.length>3&&!ignore.test(l))||"";
        if(!pick) return null;
        return pack(true,[pick.replace(/^#\s*|^[-*•]\s*/,"").slice(0,220)],`Wiktionary (${host})`,{score:SCORE.WIKI,ttlSec:TTL.WEAK});
      }catch{ return null; }
    };
  }

  const DRIVERS={
    ko:[KO_STD_KEY&&koStdDriver, wiktionaryDriver('ko')].filter(Boolean),
    ja:[jishoDriver, wiktionaryDriver('ja')],
    zh:[moeDictDriver, wiktionaryDriver('zh')],
    ru:[YA_DICT_KEY&&yandexRuDriver, wiktionaryDriver('ru')].filter(Boolean),
    de:[DWDS_TOKEN&&dwdsDriver, wiktionaryDriver('de')].filter(Boolean),
    es:[wiktionaryDriver('es')], pt:[dicionarioAbertoDriver, wiktionaryDriver('pt')],
    tr:[tdkDriver, wiktionaryDriver('tr')], fr:[wiktionaryDriver('fr')],
    en:[dictionaryApiDevDriver, wiktionaryDriver('en')], "*":[wiktionaryDriver('en')]
  };

  async function resolveDefs(term, lang){
    const L0=canonLang(lang||'en'); const L1=L0.includes('-')?L0.split('-')[0]:L0;
    const chain=DRIVERS[L0]||DRIVERS[L1]||DRIVERS["*"];
    const key=`def:${L0}:${term.toLowerCase()}`; const cached=readCache(key); if(cached) return cached;
    let best=null;
    for(const driver of chain){
      const r=await safeCall(()=>driver(term, L0));
      if(r?.ok){ best=chooseBetter(best,r); if(best?.score>=0.85) break; }
    }
    if((!best||!best.ok)&&L0!=='en'){ const en=await safeCall(()=>DRIVERS.en[0](term,'en')); if(en?.ok) best=chooseBetter(best,en); }
    if(!best) best=pack(true,[`No definition found for “${term}”.`],'fallback',{score:0.3,ttlSec:TTL.WEAK});
    writeCache(key,best,best.ttlSec||TTL.OK); return best;
  }

  const normalizeWord=s=>String(s||'').toLowerCase().trim().match(/^[a-z][a-z-]{2,22}$/)?.[0]||'';
  function sanitizeNodeList(words, cap=24){
    const seen=new Set(), out=[];
    for(const w of (words||[])){
      const t=normalizeWord(typeof w==='string'?w:(w?.word||w?.id||w?.label||'')); if(!t||seen.has(t)) continue;
      seen.add(t); out.push({id:t,label:t}); if(out.length>=cap) break;
    } return out;
  }

  async function fetchThesaurusFromDatamuse(word){
    const enc=encodeURIComponent;
    const [dmSyn,dmAnt,dmML,dmTRG]=await Promise.all([
      fetch(`https://api.datamuse.com/words?rel_syn=${enc(word)}&max=100`).then(r=>r.json()).catch(()=>[]),
      fetch(`https://api.datamuse.com/words?rel_ant=${enc(word)}&max=100`).then(r=>r.json()).catch(()=>[]),
      fetch(`https://api.datamuse.com/words?ml=${enc(word)}&max=100`).then(r=>r.json()).catch(()=>[]),
      fetch(`https://api.datamuse.com/words?rel_trg=${enc(word)}&max=100`).then(r=>r.json()).catch(()=>[]),
    ]);
    const toWord=x=>(x&&(x.word||x.id||x.label)||'').toLowerCase().trim();
    const synNodes=sanitizeNodeList(dmSyn.map(toWord),24);
    const antNodes=sanitizeNodeList(dmAnt.map(toWord),24);
    const used=new Set([...synNodes,...antNodes].map(n=>n.id));
    const relNodes=sanitizeNodeList([...dmML,...dmTRG].map(toWord).filter(w=>!used.has(w)),24);
    const groups=[]; if(synNodes.length) groups.push({label:'synonyms',nodes:synNodes});
    if(antNodes.length) groups.push({label:'antonyms',nodes:antNodes});
    if(relNodes.length) groups.push({label:'related',nodes:relNodes});
    return {groups};
  }
  async function fetchThesaurusFromDictApi(word){
    const json=await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${encodeURIComponent(word)}`).then(r=>r.json()).catch(()=>null);
    const syn=new Set(), ant=new Set();
    if(Array.isArray(json)){
      for(const e of json){
        for(const m of (e.meanings||[])){
          (m.synonyms||[]).forEach(w=>syn.add(String(w).toLowerCase()));
          (m.antonyms||[]).forEach(w=>ant.add(String(w).toLowerCase()));
          for(const d of (m.definitions||[])){
            (d.synonyms||[]).forEach(w=>syn.add(String(w).toLowerCase()));
            (d.antonyms||[]).forEach(w=>ant.add(String(w).toLowerCase()));
          }
        }
      }
    }
    const groups=[]; const synNodes=sanitizeNodeList([...syn],24); const antNodes=sanitizeNodeList([...ant],24);
    if(synNodes.length) groups.push({label:'synonyms',nodes:synNodes});
    if(antNodes.length) groups.push({label:'antonyms',nodes:antNodes});
    return {groups};
  }
  async function buildGraphData(lemma){
    let j=null; try{ j=await fetchThesaurusFromDatamuse(lemma); }catch{}
    if(!j?.groups?.length){ try{ j=await fetchThesaurusFromDictApi(lemma); }catch{} }
    const groups=Array.isArray(j?.groups)?j.groups:[];
    const center=normalizeWord(lemma)||String(lemma||'').toLowerCase();
    const nodes=[{id:center, group:'center'}], links=[];
    const colorBy={synonyms:1, antonyms:2, related:3};
    for(const g of groups){
      for(const n of (g.nodes||[])){
        if(!nodes.some(x=>x.id===n.id)) nodes.push({id:n.id, group: colorBy[g.label]||3});
        links.push({source:center, target:n.id});
      }
    }
    return {nodes, links, _empty: !groups.length};
  }

  // ---------- 3D Graph ----------
  const ensureOnceMemo=Object.create(null);
  async function ensureLibOnce(globalName, src, timeoutMs=8000){
    if(window[globalName]) return window[globalName];
    if(ensureOnceMemo[globalName]) return ensureOnceMemo[globalName];
    ensureOnceMemo[globalName]=new Promise((resolve,reject)=>{
      const id=`vws-lib-${globalName.toLowerCase()}`; const prev=document.getElementById(id);
      let done=false; const ok=()=>{ if(!done){ done=true; resolve(window[globalName]); } };
      const bad=e=>{ if(!done){ done=true; delete ensureOnceMemo[globalName]; reject(e); } };
      const t=setTimeout(()=>bad(new Error(`Timeout loading ${globalName} from ${src}`)), timeoutMs);
      if(prev){ prev.addEventListener('load',()=>{clearTimeout(t);ok();},{once:true}); prev.addEventListener('error',e=>{clearTimeout(t);bad(e)},{once:true}); return; }
      const s=document.createElement('script'); s.id=id; s.src=src; s.async=true;
      s.onload=()=>{clearTimeout(t);ok();}; s.onerror=e=>{clearTimeout(t);bad(e);}; document.head.appendChild(s);
    }); return ensureOnceMemo[globalName];
  }
  async function ensureLibOnceMulti(globalName, srcs){
    if(window[globalName]) return window[globalName];
    let lastErr; for(const s of srcs||[]){ try{ await ensureLibOnce(globalName, s); if(window[globalName]) return window[globalName]; }catch(e){ lastErr=e; } }
    throw lastErr || new Error('CSP blocked all sources for '+globalName);
  }
  function ensureHintWrap(root){ let w=root.querySelector('.vlx-hintwrap'); if(!w){ w=document.createElement('div'); w.className='vlx-hintwrap'; root.appendChild(w); } return w; }
  function show3DNotice(root,{text,onRetry}){
    const wrap=ensureHintWrap(root); wrap.innerHTML='';
    const box=document.createElement('div'); box.className='vlx-notice'; box.setAttribute('role','status'); box.setAttribute('aria-live','polite');
    box.innerHTML=`<span class="vlx-dot"></span><span>${text}</span><button type="button" data-retry>Retry</button><a href="https://datamuse.com/api/" target="_blank" rel="noopener">Allow domains</a>`;
    wrap.appendChild(box); box.querySelector('[data-retry]')?.addEventListener('click', e=>{ e.stopPropagation(); onRetry?.(); }); return box;
  }
  const FILLER=new Set(['scene','illustration','image','picture','object','thing']);
  const pickEnglishFromDefs=pack=>{ const txt=(pack?.defs||[]).join(' '); const hits=(txt.match(/\b[a-z]{3,}\b/gi)||[]).map(s=>s.toLowerCase());
    for(const p of ['man','woman','person','child','dog','cat','car','tree','house','book','chair','bird','fruit','food','sound','face','hand','eye','sun','rain']) if(hits.includes(p)) return p; return hits[0]||''; };
  function pickEnglishPivot(wordRaw, defPack, graph, lemmaLang){
    if(canonLang(lemmaLang)==='en') return String(wordRaw||'').trim();
    const nei=(graph?.vectorNeighbors||[]).map(n=>String(n.label||'').toLowerCase()).find(l=>/^[a-z]/.test(l)&&!FILLER.has(l));
    return nei || pickEnglishFromDefs(defPack) || String(wordRaw||'').trim();
  }

  async function mountThesaurus3D({container, word, pivot}){
    const root=typeof container==='string'?document.querySelector(container):container; if(!root) return;
    root.innerHTML='<div style="padding:10px;color:#888">Loading 3D graph…</div>'; root.classList.add('loading');
    try{
      const threeSrcs=[window.VLX_3D_THREE_SRC, (window.VLX_STATIC&&window.VLX_STATIC.replace(/\/$/,'')+'/three.min.js'),
        'https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.min.js','https://unpkg.com/three@0.161.0/build/three.min.js'].filter(Boolean);
      const fgSrcs=[window.VLX_3D_FG_SRC, (window.VLX_STATIC&&window.VLX_STATIC.replace(/\/$/,'')+'/3d-force-graph.min.js'),
        'https://cdn.jsdelivr.net/npm/3d-force-graph@1.73.3/dist/3d-force-graph.min.js','https://unpkg.com/3d-force-graph@1.73.3/dist/3d-force-graph.min.js'].filter(Boolean);

      if(!window.THREE) await ensureLibOnceMulti('THREE', threeSrcs);
      const FG=await ensureLibOnceMulti('ForceGraph3D', fgSrcs);

      const data=await buildGraphData(pivot||word); root.innerHTML=''; if(root.clientHeight<120) root.style.height='360px';

      try{
        const spriteSrcs=[window.VLX_3D_SPRITE_SRC, (window.VLX_STATIC&&window.VLX_STATIC.replace(/\/$/,'')+'/three-spritetext.min.js'),
          'https://unpkg.com/three-spritetext/dist/three-spritetext.min.js'].filter(Boolean);
        if(!window.SpriteText) await ensureLibOnceMulti('SpriteText', spriteSrcs);
      }catch{}

      const GROUP_COLORS={center:0x7aa2ff,synonyms:0x22c55e,antonyms:0xef4444,default:0x60a5fa};
      const colOf=g=>GROUP_COLORS[String(g||'default').toLowerCase()]??GROUP_COLORS.default;
      const hex=c=>'#'+c.toString(16).padStart(6,'0');

      function makeLabel(text,colorHex,isCenter){
        try{
          if(window.SpriteText){
            const t=new SpriteText(text); t.color='#e6eefc';
            t.backgroundColor=`rgba(${(colorHex>>16)&255},${(colorHex>>8)&255},${colorHex&255},0.90)`;
            t.textHeight=isCenter?10:7; t.padding=10; t.material.depthTest=false; t.material.depthWrite=false; t.renderOrder=999; t.position.set(0,14,0);
            return t;
          }
        }catch{}
        const pad=24, fs=64, cv=document.createElement('canvas'), ctx=cv.getContext('2d');
        ctx.font=`600 ${fs}px ui-sans-serif, system-ui`; const w=Math.ceil(ctx.measureText(text).width)+pad*2, h=fs+pad*2; cv.width=w; cv.height=h;
        ctx.fillStyle=`rgba(${(colorHex>>16)&255},${(colorHex>>8)&255},${colorHex&255},0.92)`; ctx.fillRect(0,0,w,h);
        ctx.fillStyle='#e6eefc'; ctx.textBaseline='middle'; ctx.fillText(text,pad,h/2);
        const tex=new THREE.CanvasTexture(cv); tex.anisotropy=4; const mat=new THREE.SpriteMaterial({map:tex,transparent:true,depthWrite:false,depthTest:false});
        const spr=new THREE.Sprite(mat); spr.renderOrder=999; spr.scale.set(w/10,h/10,1); spr.position.set(0,14,0); return spr;
      }

      const fg=FG({rendererConfig:{preserveDrawingBuffer:true,antialias:true,alpha:true}})(root)
        .nodeId('id').backgroundColor('#0b0f17').nodeRelSize(6).linkOpacity(0.35).linkWidth(0.6)
        .warmupTicks(60).cooldownTime(6500).onNodeDragEnd(n=>{n.fx=n.x;n.fy=n.y;n.fz=n.z;})
        .nodeThreeObject(n=>{ const color=colOf(n.group); const g=new THREE.Group();
          g.add(new THREE.Mesh(new THREE.SphereGeometry((n.group==='center'?7:5)*0.6,16,16), new THREE.MeshBasicMaterial({color})));
          const lbl=makeLabel(n.label||n.id,color,n.group==='center'); n.__label=lbl; g.add(lbl); return g; })
        .nodeColor(n=>hex(colOf(n.group)))
        .linkColor(l=>{ const tgt=(typeof l.target==='object')?l.target:fg.graphData().nodes.find(n=>n.id===l.target); return hex(colOf(tgt?.group)); })
        .onNodeClick(n=>{ const dist=90, r=1+dist/Math.hypot(n.x||1,n.y||1,n.z||1);
          fg.cameraPosition({x:(n.x||0)*r,y:(n.y||0)*r,z:(n.z||0)*r}, n, 800); qEl.value=n.id; run(); });

      fg.graphData(data);
      const linkF=fg.d3Force('link');
      linkF.distance(l=>{ const s=(typeof l.source==='object')?l.source:fg.graphData().nodes.find(n=>n.id===l.source);
        const t=(typeof l.target==='object')?l.target:fg.graphData().nodes.find(n=>n.id===l.target);
        return (s?.group==='center'||t?.group==='center')?60:90; });
      fg.d3Force('charge').strength(-180);
      let fitOnce=false; fg.onEngineStop(()=>{ if(!fitOnce){ fitOnce=true; fg.zoomToFit(600,60); } });
      const size=()=>{ fg.width(root.clientWidth).height(root.clientHeight); }; size(); addEventListener('resize', size);

      if(data._empty){
        show3DNotice(root,{ text:'No related words. Possibly blocked by CSP. (api.datamuse.com / dictionaryapi.dev)',
          onRetry: async()=>{ root.classList.add('loading'); const fresh=await buildGraphData(pivot||word); fg.graphData(fresh); root.classList.remove('loading');
            const wrap=root.querySelector('.vlx-hintwrap'); if(!fresh._empty&&wrap) wrap.innerHTML=''; }});
      }else{ const wrap=root.querySelector('.vlx-hintwrap'); if(wrap) wrap.innerHTML=''; }
    }catch(e){
      show3DNotice(document.querySelector(container), {text:'3D library blocked by CSP/CDN', onRetry:()=>mountThesaurus3D({container,word,pivot})});
    }finally{ document.querySelector(container)?.classList.remove('loading'); }
  }

  const hardMap={};
  function phraseByPOS(word, defPack, fall){
    const pos=defPack?.pos||[]; const f=(fall||word||'').toString().trim(); if(!f) return '';
    const isLatin=/^[a-z]/i.test(f);
    if(pos.some(p=>/verb/i.test(p))) return isLatin?`person ${f}ing`:f;
    if(pos.some(p=>/adjective/i.test(p))) return isLatin?`${f} object`:f;
    return isLatin?`${f} photo`:f;
  }

  async function refineImages(wordRaw, uiLang, defPack, imgs, graph, lemmaLang){
    const mode=(imgs?.mode||'').toLowerCase();
    const isAi = /^ai(?:-|_)/.test(mode);
    const noImages = !(Array.isArray(imgs?.imageUrls)&&imgs.imageUrls.length) && !(Array.isArray(imgs?.images)&&imgs.images.length);
    const needsRefine = noImages || (mode.includes('vector-word') && canonLang(lemmaLang)!=='en');
    if (isAi) return { imgs, refined:false, phrase: imgs?.base || null };
    if (!needsRefine) return { imgs, refined:false, phrase:null };

    let phrase=hardMap[wordRaw?.toLowerCase?.()] || hardMap[wordRaw];
    if(!phrase){
      const neighbor=(graph?.vectorNeighbors||[]).map(n=>String(n.label||'').toLowerCase()).find(l=>l&&!FILLER.has(l));
      if(neighbor) phrase=phraseByPOS(neighbor, defPack, neighbor);
    }
    if(!phrase && !/^[a-z]/i.test(wordRaw)){
      const picked=pickEnglishFromDefs(defPack); if(picked) phrase=phraseByPOS(picked, defPack, picked);
    }
    if(!phrase) phrase=phraseByPOS(wordRaw, defPack, wordRaw);
    phrase=phrase.replace(/\b(scene|image|picture|object|thing)\b/ig,'').replace(/\s{2,}/g,' ').trim();
    if(!phrase) phrase=(/^[a-z]/i.test(String(wordRaw)))?`${wordRaw} photo`:String(wordRaw);

    const try1=await getVLImages(phrase,{source:'commons'}); if(try1?.imageUrls?.length) return {imgs:try1, refined:true, phrase};
    const base=(phrase.split(' ')[0]||wordRaw); const try2=await getVLImages(`${base} illustration`,{source:'commons'});
    if(try2?.imageUrls?.length) return {imgs:try2, refined:true, phrase:`${base} illustration`};
    return { imgs, refined:false, phrase:null };
  }

  async function suggestWiktionary(term, lang){
    try{
      const u=`https://${hostFromLang(lang)}.wiktionary.org/w/api.php?action=query&list=prefixsearch&pssearch=${encodeURIComponent(term)}&pslimit=10&format=json&origin=*`;
      const r=await fetch(u); if(!r.ok) return []; const j=await r.json(); return (j?.query?.prefixsearch||[]).map(x=>x.title).filter(Boolean);
    }catch{ return []; }
  }
  const suggestDatamuse=async term=>{ try{ const r=await fetch('https://api.datamuse.com/sug?s='+encodeURIComponent(term)); if(!r.ok) return []; const j=await r.json(); return j.map(x=>x.word).filter(Boolean); }catch{ return []; } };
  async function getSuggestions(term){
    const lang=guessLang(term); const a=await suggestWiktionary(term, lang);
    const b=canonLang(lang)==='en' ? (await suggestDatamuse(term)) : []; return uniq([...a, ...b]).slice(0,12);
  }
  function romanForDisplay(lang, word){
    const L=canonLang(lang); if(L==='ko') return romanizeKo(word); if(L==='ja') return romanizeJa(word); return '';
  }
  const KO_CHO=["g","kk","n","d","tt","r","m","b","pp","s","ss","","j","jj","ch","k","t","p","h"];
  const KO_JUNG=["a","ae","ya","yae","eo","e","yeo","ye","o","wa","wae","oe","yo","u","wo","we","wi","yu","eu","ui","i"];
  const KO_JONG=["","k","k","k","n","n","n","t","l","k","m","p","t","t","ng","t","t","k","t","p","t","k","t","p","t","k","t","p"];
  function romanizeKo(str){ let out=''; for(const ch of str){ const code=ch.codePointAt(0);
    if(code>=0xAC00 && code<=0xD7A3){ const sIndex=code-0xAC00; const cho=Math.floor(sIndex/588); const jung=Math.floor((sIndex%588)/28); const jong=sIndex%28;
      out+=(KO_CHO[cho]||'')+KO_JUNG[jung]+KO_JONG[jong]; } else out+=ch; } return out; }
  const JA_MAP={ 'あ':'a','い':'i','う':'u','え':'e','お':'o','か':'ka','き':'ki','く':'ku','け':'ke','こ':'ko','さ':'sa','し':'shi','す':'su','せ':'se','そ':'so','た':'ta','ち':'chi','つ':'tsu','て':'te','と':'to','な':'na','に':'ni','ぬ':'nu','ね':'ne','の':'no','は':'ha','ひ':'hi','ふ':'fu','へ':'he','ほ':'ho','ま':'ma','み':'mi','む':'mu','め':'me','も':'mo','や':'ya','ゆ':'yu','よ':'yo','ら':'ra','り':'ri','る':'ru','れ':'re','ろ':'ro','わ':'wa','ゐ':'wi','ゑ':'we','を':'o','ん':'n' };
  const kataToHira=s=>s.replace(/[ァ-ン]/g,ch=>String.fromCharCode(ch.charCodeAt(0)-0x60));
  function romanizeJa(str){ let hira=kataToHira(str); hira=hira.replace(/っ([か-ぢつ-もやゆよら-ろわゐゑをんが-ぽ])/g,(_,n)=>{ const r=JA_MAP[n]||''; return (r[0]||'')+n; });
    let out=''; for(let i=0;i<hira.length;i++){ const two=hira.slice(i,i+2); if(JA_MAP[two]){ out+=JA_MAP[two]; i++; continue; } const ch=hira[i];
      if(ch==='ー'){ const prev=out[out.length-1]||''; out+=prev; continue; } out+=(JA_MAP[ch]||ch); } return out; }

  function renderSuggestions(items){
    const lang=guessLang(qEl.value.trim());
    if(!SHOW_SUGGESTIONS || !items.length){ sugEl.style.display='none'; sugEl.innerHTML=''; return; }
    sugEl.innerHTML=`<ul>${items.map(w=>{
      const rom=/[가-힣ぁ-ゔァ-ヴー々〆〤一-龥]/.test(w)?romanForDisplay(lang,w):''; return `<li data-word="${esc(w)}"><span>${esc(w)}</span>${rom?`<span class="vlx-sug-roman">${esc(rom)}</span>`:''}</li>`;
    }).join('')}</ul>`;
    sugEl.style.display='block';
    sugEl.querySelectorAll('li').forEach(li=>li.addEventListener('click',()=>{ qEl.value=li.dataset.word||li.textContent; hideSuggestions(); run(); }));
  }
  const hideSuggestions=()=>{ sugEl.style.display='none'; };
  function setHTML(id, html, showIf=true){ const n=$(id); n.innerHTML=html||''; if(n.parentElement) n.parentElement.style.display=(showIf&&html)?'':'none'; }
  const trans={ lang:'en', mounted:false };
  function mountLangBar(){
    if(trans.mounted) return;
    const bar=$('vlx-trans-lang');
    bar.innerHTML=LANG_OPTIONS.map(o=>`<button class="vlx-langbtn" data-lang="${o.code}" title="${esc(o.label)}">${esc(o.label)}</button>`).join('');
    bar.addEventListener('click', e=>{
      const btn=e.target.closest('.vlx-langbtn'); if(!btn) return;
      trans.lang=btn.dataset.lang||'en';
      [...bar.querySelectorAll('.vlx-langbtn')].forEach(b=>b.classList.toggle('active', b===btn));
      if(trans.currentWord) renderTranslation(trans.currentWord);
    });
    (bar.querySelector(`[data-lang="${trans.lang}"]`)||bar.querySelector('.vlx-langbtn'))?.classList.add('active');
    trans.mounted=true;
  }
  async function fetchDefForLang(lemma, lang){
    const u=new URL(urlOf('def')); u.searchParams.set('lemma', lemma); u.searchParams.set('lang', lang);
    return await j(u.toString(), lang);
  }
  async function renderTranslation(word){
    const box=$('vlx-trans-body'); box.innerHTML='Loading…';
    try{
      const data=await fetchDefForLang(word, trans.lang) || {};
      const defs=(data?.definitionsTranslated?.length?data.definitionsTranslated:data.definitions)||[];
      const t=data.translation?`<p style="margin:.25rem 0;font-weight:600">${esc(data.translation)}</p>`:'';
      const au=data.audio?`<audio controls preload="metadata" style="width:100%;margin:.25rem 0" src="${esc(data.audio)}"></audio>`:'';
      const dl=defs.length?`<ul style="padding-left:1rem;margin:.25rem 0">${defs.slice(0,8).map(d=>`<li>${esc(d)}</li>`).join('')}</ul>`:small('No translated definitions.');
      box.innerHTML=t+au+dl;
    }catch{ box.innerHTML=small('Failed to load translation.'); }
  }

  async function renderAll(word, uiLang, defPack, graph, imgs, refineInfo, antonyms, fallbackDict){
    cardEl.style.display='block';
    const base=imgs?.base;
    $('vlx-word').textContent=(base&&base!==word)?`${word} (${base})`:word;
    const ipa=defPack?.ipa || fallbackDict?.ipa || ''; const audio=defPack?.audio || fallbackDict?.ipaAudio || '';
    $('vlx-ipa').textContent=ipa?`/${ipa.replace(/^\/|\/$/g,'')}/`:''; const audioEl=$('vlx-audio'); try{audioEl.pause();}catch{} audioEl.removeAttribute('src'); audioEl.load(); audioEl.style.display='none';
    if(audio){ audioEl.src=audio; audioEl.style.display=''; }

    const mode=String(imgs?.mode||''); const urls=(imgs?.imageUrls || (imgs?.images||[]).map(i=>i.url) || []).slice(0,MAX_IMGS);
    $('vlx-imgs').innerHTML=urls.map(u=>`<div class="vlx-imgbox"><img src="${esc(u)}" loading="lazy" alt="${esc(word)}"></div>`).join('');
    const caption = mode ? `image mode: ${mode}` : '';
    const aiChip = (mode.toLowerCase().startsWith('ai') && base)?` <span class="vlx-tag">AI: ${esc(base)}</span>`:'';
    const refinedChip = (!mode.toLowerCase().startsWith('ai') && refineInfo?.refined && refineInfo.phrase)?` <span class="vlx-tag">refined: ${esc(refineInfo.phrase)}</span>`:'';
    $('vlx-img-caption').innerHTML=(caption?`<span class="vlx-tag">${caption}</span>`:'')+aiChip+refinedChip;

    const qNote = $('vlx-quota');
    qNote.innerHTML = quotaMessage(document.documentElement.lang || 'en');
    qNote.style.display = 'inline-flex';

    const modeTag=$('vlx-mode'); if(mode){ modeTag.textContent=mode; modeTag.style.display='inline-block'; } else modeTag.style.display='none';
    const aiTag=$('vlx-ai-pair');
    if(mode.toLowerCase().startsWith('ai') && base){ aiTag.textContent=`AI: ${base}`; aiTag.style.display='inline-block'; }
    else if(refineInfo?.refined && refineInfo.phrase){ aiTag.textContent=`refined: ${refineInfo.phrase}`; aiTag.style.display='inline-block'; }
    else aiTag.style.display='none';

    const defs=(defPack?.defs||[]).slice(0,3);
    setHTML('vlx-defs', defs.length? `<ul class="vlx-list">${defs.map(li).join('')}</ul>` : small('No definition found.'));
    setHTML('vlx-def-source', defPack?.source ? `Source: ${defPack.source}` : '');

    const pos=defPack?.pos || [];
    setHTML('vlx-pos', pos.length? pos.map(chip).join('') : small('—'));

    const graphSyn=(graph?.vectorNeighbors||[]).map(n=>n.label);
    const syn=uniq([...(defPack?.syn||[]), ...graphSyn]).slice(0,18);
    const ant=uniq([...(defPack?.ant||[]), ...(antonyms||[])]).slice(0,16);
    setHTML('vlx-synant',
      (syn.length? `<div><strong>Syn:</strong> ${syn.map(chip).join(' ')}</div>`:'' ) +
      (ant.length? `<div style="margin-top:6px"><strong>Ant:</strong> ${ant.map(chip).join(' ')}</div>`:'' ) || small('—')
    );

    const showDer=/^[a-z]+$/i.test(word); const der=showDer?(()=>{
      const s=new Set(), x=word.toLowerCase(), push=v=>v&&s.add(v);
      push(x+'s'); push(x+'ed'); push(x+'ing'); push(x+'er'); push(x+'ers'); push(x+'ment'); push(x+'ments');
      if(x.endsWith('y')) push(x.slice(0,-1)+'ies');
      if(x.endsWith('e')) push(x.slice(0,-1)+'ing');
      if(x.endsWith('ies')) push(x.slice(0,-3)+'y');
      if(x.endsWith('es')) push(x.slice(0,-2));
      if(x.endsWith('s')&&!x.endsWith('ss')) push(x.slice(0,-1));
      return Array.from(s).slice(0,12);
    })() : [];
    $('sec-der').style.display=showDer && der.length ? '' : 'none';
    setHTML('vlx-der', showDer && der.length? der.map(chip).join('') : '');

    const isEnUI=canonLang(uiLang)==='en';
    const ex=isEnUI ? (defPack?.examples || []) : [];
    if(isEnUI && ex.length){ $('sec-ex').style.display=''; setHTML('vlx-ex', `<ul class="vlx-list">${ex.map(li).join('')}</ul>`, true); }
    else { $('sec-ex').style.display='none'; setHTML('vlx-ex','',false); }

    mountLangBar(); trans.currentWord=word;
    const lemmaForTrans = (mode.startsWith('ai') && base) ? base : word;
    renderTranslation(lemmaForTrans);

    // AI disclaimer (English)
    const aiNote=$('vlx-ai-note');
    aiNote.innerHTML = 'AnySearch uses AI and may occasionally produce incorrect, misleading, or biased results. Please verify important information.';
    aiNote.style.display='inline-flex';

    const pivot=pickEnglishPivot(word, defPack, graph, guessLang(word));
    await mountThesaurus3D({container:'#vlx-3d', word, pivot});
  }

  // ---------- Run ----------
  async function run(){
    const raw=qEl.value.trim(); if(!raw) return;
    const uiLang=getUiLang(raw); const lemmaLang=guessLang(raw); const isEnglish=canonLang(lemmaLang)==='en';
    hideSuggestions(); spinEl.style.display='inline-block'; statusEl.textContent='Searching…'; cardEl.style.display='none';

    const [imgsR, defR, graphR, dictR, antR]=await Promise.allSettled([
      getVLImages(raw, decideImageOpts()),
      resolveDefs(raw, lemmaLang),
      getVLGraph(raw, lemmaLang),
      isEnglish ? dictionaryApiDevDriver(raw) : Promise.resolve(null),
      isEnglish ? (async()=>{ try{ const r=await fetch('https://api.datamuse.com/words?rel_ant='+encodeURIComponent(raw)); return (await r.json()).slice(0,16).map(x=>x.word).filter(Boolean);}catch{return [];} })() : Promise.resolve([])
    ]);

    let imgs = imgsR.status==='fulfilled' ? (imgsR.value||{}) : {};
    const defs  = defR.status==='fulfilled' ? (defR.value||{}) : {};
    const graph = graphR.status==='fulfilled'? (graphR.value||{}) : {};
    const dict  = dictR.status==='fulfilled' ? (dictR.value||null): null;
    const antonyms = antR.status==='fulfilled' ? (antR.value||[]) : [];

    if(IMG_MODE==='auto'){
      const noImgs = !(Array.isArray(imgs?.imageUrls)&&imgs.imageUrls.length) && !(Array.isArray(imgs?.images)&&imgs.images.length);
      if(noImgs){ try{ const retry=await getVLImages(raw,{source:'commons'}); if((retry?.imageUrls?.length)||(retry?.images?.length)) imgs=retry; }catch{} }
    }

    const refineInfo=await refineImages(raw, uiLang, defs, imgs, graph, lemmaLang); imgs=refineInfo.imgs;

    if((!imgs?.imageUrls?.length) && (!defs?.defs?.length)){
      statusEl.innerHTML='No content returned. If this site is on a different domain than <code>api.visuallexicon.org</code>, cookies may be blocked. Use a same-origin proxy (<code>window.VLX_PROXY</code>) or set <code>window.VLX_TOKEN</code>.';
    }else statusEl.textContent='';

    spinEl.style.display='none';
    renderAll(raw, uiLang, defs, graph, imgs, refineInfo, antonyms, dict);
  }

  // ---------- Events ----------
  goEl.addEventListener('click', e=>{ e.preventDefault(); run(); });
  qEl.addEventListener('keydown', e=>{ if(e.key==='Enter'){ e.preventDefault(); hideSuggestions(); run(); } else if(e.key==='Escape'){ hideSuggestions(); } });
  if(AUTO_SEARCH_ON_INPUT){ qEl.addEventListener('input', debounce(()=>{ const v=qEl.value.trim(); if(v.length>=2) run(); },600)); }
  qEl.addEventListener('input', debounce(async()=>{ if(!SHOW_SUGGESTIONS) return; const v=qEl.value.trim(); if(v.length<2){ hideSuggestions(); return; } renderSuggestions(await getSuggestions(v)); },220));
  document.addEventListener('click', e=>{ if(!sugEl.contains(e.target) && e.target!==qEl) hideSuggestions(); }, true);
  qEl.addEventListener('keydown', e=>{
    if(sugEl.style.display!=='block') return;
    const rows=[...sugEl.querySelectorAll('li')]; if(!rows.length) return;
    const i=rows.findIndex(li=>li.classList.contains('active'));
    if(e.key==='ArrowDown'){ e.preventDefault(); const ni=Math.min(rows.length-1, i+1); rows.forEach(r=>r.classList.remove('active')); rows[ni].classList.add('active'); rows[ni].scrollIntoView({block:'nearest'}); }
    else if(e.key==='ArrowUp'){ e.preventDefault(); const ni=Math.max(0, i-1); rows.forEach(r=>r.classList.remove('active')); rows[ni].classList.add('active'); rows[ni].scrollIntoView({block:'nearest'}); }
    else if(e.key==='Enter' && i>=0){ e.preventDefault(); qEl.value=rows[i].dataset.word||rows[i].textContent; hideSuggestions(); run(); }
  });
})();
</script>
</html>
