<script>
/* =========================================================
   AnySearch (AI-only) — Visual Lexicon
   - external dictionary/thesaurus calls removed
   - translation panel moved directly under images
   ========================================================= */

window.VLX_PROXY = '/vlx';
window.VLX_3D_THREE_SRC = "https://chachathecat.github.io/vlx-static/vendor/three.min.js";
window.VLX_3D_FG_SRC    = "https://chachathecat.github.io/vlx-static/vendor/3d-force-graph.min.js";

(function(){
  // ---------- Config ----------
  const API_BASE   = (window.VLX_PROXY && String(window.VLX_PROXY)) || "https://api.visuallexicon.org";
  const AUTH_TOKEN = (window.VLX_TOKEN && String(window.VLX_TOKEN)) || null;

  const MAX_IMGS   = 3;
  const SHOW_SUGGESTIONS = false; // 외부 제안 API 제거 → 비활성화
  const DEFAULT_IMAGE_POLICY = 'auto'; // 'auto' | 'commons' | 'default'
  const AUTO_SEARCH_ON_INPUT = false;

  const LANG_OPTIONS = [
    { code:"en", label:"English" },{ code:"ko", label:"한국어" },{ code:"ja", label:"日本語" },
    { code:"zh", label:"中文" },{ code:"es", label:"Español" },{ code:"hi", label:"हिन्दी" },
    { code:"fr", label:"Français" },{ code:"ar", label:"اَلْعَرَبِيَّةُ" },{ code:"bn", label:"বাংলা" },
    { code:"ru", label:"русский язык" },{ code:"pt", label:"português" },{ code:"id", label:"Bahasa Indonesia" },
    { code:"de", label:"Deutsch" },{ code:"vi", label:"Tiếng Việt" },{ code:"tr", label:"Türkçe" },{ code:"ur", label:"اردو" }
  ];

  // ---------- Shorthands ----------
  const $ = id => document.getElementById(id);
  const small = s => `<div class="vlx-small">${s}</div>`;
  const chip  = s => `<span class="vlx-chip">${s}</span>`;
  const li    = s => `<li>${s}</li>`;
  const esc   = s => (s||'').replace(/[&<>]/g,m=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[m]));
  const uniq  = a => Array.from(new Set((a||[]).filter(Boolean)));
  const debounce=(fn,ms=400)=>{let t;return(...a)=>{clearTimeout(t);t=setTimeout(()=>fn(...a),ms);};};

  // Sticky header padding
  const headerEl = document.querySelector('.vlx-row');
  const applyHeaderGap=()=>{ const h=(headerEl?.offsetHeight||64);
    document.documentElement.style.setProperty('--vlx-header-h', h+'px');
    document.documentElement.style.scrollPaddingTop = h+'px';
    document.body.style.scrollPaddingTop = h+'px';
  };
  applyHeaderGap(); addEventListener('resize', applyHeaderGap); setTimeout(applyHeaderGap, 0);

  // ---------- Fetch helpers ----------
  const sleep = (ms)=> new Promise(r=>setTimeout(r, ms));
  const join=(b,p)=> (b.endsWith('/')?b.slice(0,-1):b) + (p.startsWith('/')?p:('/'+p));
  const urlOf= p => { const s=join(API_BASE,p); try{ return new URL(s, location.origin).toString(); }catch{ return s; } };
  const SEND_COOKIES = (new URL(API_BASE, location.href).origin === location.origin) && !AUTH_TOKEN;

  async function j(url, lang){
    const headers = { 'Accept-Language': lang || 'en' };
    if (AUTH_TOKEN) headers['Authorization'] = `Bearer ${AUTH_TOKEN}`;
    const ctrl=new AbortController(); const to=setTimeout(()=>ctrl.abort(), 12000);
    try{
      const res=await fetch(url,{ method:'GET', mode:'cors', cache:'no-store',
        credentials: SEND_COOKIES?'include':'omit', headers, signal:ctrl.signal });
      if(res.status===401) throw new Error('login-required');
      if(!res.ok){ const txt=await res.text().catch(()=> ''); throw new Error(`HTTP ${res.status} ${res.statusText} — ${txt.slice(0,160)}`); }
      return await res.json();
    }catch(err){
      const msg=String(err?.message||err);
      $('vlx-status').innerHTML = (msg==='login-required')
        ? 'Please <a href="/login" style="text-decoration:underline">log in</a> to use the inline dictionary.'
        : `API error: ${esc(msg)}`;
      return null;
    }finally{ clearTimeout(to); }
  }

  const settleWith = (p, ms, fallback) =>
    Promise.race([ p, new Promise(res => setTimeout(()=>res(fallback), ms)) ]);

  // ---------- Lang utils ----------
  function guessLang(t){
    if(/[가-힣]/.test(t)) return 'ko';
    if(/[ぁ-ゔァ-ヴー々〆〤]/.test(t)) return 'ja';
    if(/[一-龥]/.test(t)) return 'zh';
    if(/[А-Яа-яЁё]/.test(t)) return 'ru';
    if(/[a-zA-Z]/.test(t)) return 'en';
    return 'en';
  }
  const canonLang = l => ({kr:'ko',jp:'ja',cn:'zh',tw:'zh-hant','zh-cn':'zh','zh-tw':'zh-hant',hk:'zh-hant'}[(l||'').toLowerCase()] || (l||'').toLowerCase() || 'en');
  function getUiLang(fallback){
    const bar = document.getElementById('vlx-trans-lang');
    const active = bar?.querySelector('[data-lang].is-active,[data-lang].active');
    if (active?.dataset?.lang) return canonLang(active.dataset.lang);
    const docLang = document.documentElement.getAttribute('lang');
    if (docLang) return canonLang(docLang);
    const navLang = navigator.language || navigator.userLanguage;
    if (navLang) return canonLang(navLang);
    return canonLang(guessLang(fallback || ''));
  }

  // ---------- VLX API wrappers ----------
  function getVLImages(word, opts={}){
    const u=new URL(urlOf(''));
    u.searchParams.set('lemma', word.trim().toLowerCase());
    u.searchParams.set('lang', getUiLang(word));                // UI 언어 힌트
    if(opts.source) u.searchParams.set('source', String(opts.source));
    return j(u.toString(), getUiLang(word));
  }
  function getVLGraph(word, lemmaLang){
    const lang=canonLang(lemmaLang||'en');                      // 원어 힌트
    const u=new URL(urlOf('graph'));
    u.searchParams.set('lemma', word.trim().toLowerCase());
    u.searchParams.set('k','12');
    u.searchParams.set('lang', lang);
    return j(u.toString(), lang);
  }
  async function fetchDefForLang(lemma, lang){                  // AI 사전(번역/발음/품사 등)
    const u=new URL(urlOf('def')); u.searchParams.set('lemma', lemma); u.searchParams.set('lang', lang);
    return await j(u.toString(), lang);
  }

  // --- MODE TOGGLE (Auto/Commons/Default) ---
  let IMG_MODE = (localStorage.getItem('VLX_IMG_MODE') || DEFAULT_IMAGE_POLICY || 'auto').toLowerCase();
  const humanMode = m => (m==='commons'?'Commons':(m==='default'?'Default':'Auto'));
  function applyModeLabel(){
    const el=$('vlx-img-toggle'); if(!el) return;
    el.textContent = `Images: ${humanMode(IMG_MODE)}`;
    const active = IMG_MODE !== 'auto';
    el.classList.toggle('active', active);
    el.setAttribute('aria-pressed', String(active));
  }
  applyModeLabel();
  $('vlx-img-toggle')?.addEventListener('click', ()=>{
    IMG_MODE = (IMG_MODE==='auto') ? 'commons' : (IMG_MODE==='commons' ? 'default' : 'auto');
    localStorage.setItem('VLX_IMG_MODE', IMG_MODE);
    applyModeLabel();
    if($('vlx-q').value.trim()) run();
  });
  const decideImageOpts=()=>{
    if (IMG_MODE === 'commons') return { source:'commons' };
    if (IMG_MODE === 'default') return {};
    try{
      const sp = new URLSearchParams(location.search);
      const qs = (sp.get('source') || sp.get('mode') || sp.get('policy') || sp.get('img') || '').toLowerCase();
      const bare = sp.has('commons') ? 'commons' : (sp.has('default') ? 'default' : '');
      const hashMatch = (location.hash.match(/(?:^|#)(commons|default)\b/i) || [])[1] ||
                        (location.hash.match(/mode=(commons|default)/i) || [])[1] || '';
      const ov = (qs || bare || hashMatch).toLowerCase();
      if (ov === 'commons') return { source:'commons' };
      if (ov === 'default') return {};
    }catch{}
    return {};
  };

  // ---------- Light heuristics (보정용) ----------
  const oppositeGuess = (w)=>{                     // AI 결과에 반의어 없을 때만 가벼운 추정
    const L=w.toLowerCase();
    const table={
      good:'bad', bad:'good', hot:'cold', cold:'hot', high:'low', low:'high',
      big:'small', small:'big', fast:'slow', slow:'fast', light:'dark', dark:'light',
      true:'false', open:'closed', old:'new', new:'old', many:'few', few:'many',
      happy:'sad', positive:'negative', negative:'positive', rich:'poor', poor:'rich'
    };
    if(table[L]) return [table[L]];
    if(/^un[^aeiou]/.test(L)) return [L.replace(/^un/,'')];
    if(/^in/.test(L)) return [L.replace(/^in/,'')];
    if(/^im/.test(L)) return [L.replace(/^im/,'')];
    if(/^ir/.test(L)) return [L.replace(/^ir/,'')];
    if(/^il/.test(L)) return [L.replace(/^il/,'')];
    if(/^dis/.test(L)) return [L.replace(/^dis/,'')];
    return [];
  };
  const guessPOS=(w)=>{                             // AI pos 미제공시
    const L=w.toLowerCase();
    if(/ly$/.test(L)) return ['adverb'];
    if(/ing$|ate$|fy$|ise$|ize$/.test(L)) return ['verb'];
    if(/ous$|ful$|less$|ive$|able$|ible$|al$|ic$|ary$|y$/.test(L)) return ['adjective'];
    return [];
  };
  const buildDerivatives=(word)=>{                  // 영어 중심 파생어
    if(!/^[a-z]+$/i.test(word)) return [];
    const s=new Set(), x=word.toLowerCase(), push=v=>v&&s.add(v);
    push(x+'s'); push(x+'ed'); push(x+'ing'); push(x+'er'); push(x+'ers'); push(x+'est');
    if(x.endsWith('y')){ push(x.slice(0,-1)+'ies'); push(x.slice(0,-1)+'ier'); }
    if(x.endsWith('e')) push(x.slice(0,-1)+'ing');
    if(x.endsWith('ies')) push(x.slice(0,-3)+'y');
    if(x.endsWith('es')) push(x.slice(0,-2));
    if(x.endsWith('s')&&!x.endsWith('ss')) push(x.slice(0,-1));
    return Array.from(s).slice(0,12);
  };

  // ---------- 3D Graph (VLX only) ----------
  const ensureOnceMemo=Object.create(null);
  async function ensureLibOnce(globalName, src, timeoutMs=8000){
    if(window[globalName]) return window[globalName];
    if(ensureOnceMemo[globalName]) return ensureOnceMemo[globalName];
    ensureOnceMemo[globalName]=new Promise((resolve,reject)=>{
      const id=`vws-lib-${globalName.toLowerCase()}`; const prev=document.getElementById(id);
      let done=false; const ok=()=>{ if(!done){ done=true; resolve(window[globalName]); } };
      const bad=e=>{ if(!done){ done=true; delete ensureOnceMemo[globalName]; reject(e); } };
      const t=setTimeout(()=>bad(new Error(`Timeout loading ${globalName} from ${src}`)), timeoutMs);
      if(prev){ prev.addEventListener('load',()=>{clearTimeout(t);ok();},{once:true}); prev.addEventListener('error',e=>{clearTimeout(t);bad(e)},{once:true}); return; }
      const s=document.createElement('script'); s.id=id; s.src=src; s.async=true;
      s.onload=()=>{clearTimeout(t);ok();}; s.onerror=e=>{clearTimeout(t);bad(e);}; document.head.appendChild(s);
    }); return ensureOnceMemo[globalName];
  }
  async function ensureLibOnceMulti(globalName, srcs){
    if(window[globalName]) return window[globalName];
    let lastErr; for(const s of srcs||[]){ try{ await ensureLibOnce(globalName, s); if(window[globalName]) return window[globalName]; }catch(e){ lastErr=e; } }
    throw lastErr || new Error('CSP blocked all sources for '+globalName);
  }

  async function buildGraphDataVLX(word, lemmaLang){
    const g = await getVLGraph(word, lemmaLang) || {};
    const center=(String(word||'').toLowerCase());
    const vec=(g.vectorNeighbors||[]).map(n=>({id:String(n.label||'').toLowerCase(),label:String(n.label||'')})).filter(n=>n.id && n.id!==center);
    const nodes=[{id:center, group:'center'}], links=[];
    for(const n of vec){ if(!nodes.some(x=>x.id===n.id)) nodes.push({id:n.id,label:n.label,group:'synonyms'}); links.push({source:center,target:n.id}); }
    return {nodes, links, _empty: !vec.length};
  }

  function show3DNotice(root,{text,onRetry}){
    let wrap=root.querySelector('.vlx-hintwrap'); if(!wrap){ wrap=document.createElement('div'); wrap.className='vlx-hintwrap'; root.appendChild(wrap); }
    wrap.innerHTML='';
    const box=document.createElement('div'); box.className='vlx-notice'; box.setAttribute('role','status'); box.setAttribute('aria-live','polite');
    box.innerHTML=`<span class="vlx-dot"></span><span>${text}</span><button type="button" data-retry>Retry</button>`;
    wrap.appendChild(box); box.querySelector('[data-retry]')?.addEventListener('click', e=>{ e.stopPropagation(); onRetry?.(); }); return box;
  }

  async function mountThesaurus3D({container, word, lemmaLang}){
    const root=typeof container==='string'?document.querySelector(container):container; if(!root) return;
    root.innerHTML='<div style="padding:10px;color:#888">Loading 3D graph…</div>'; root.classList.add('loading');
    try{
      const threeSrcs=[window.VLX_3D_THREE_SRC,
        'https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.min.js','https://unpkg.com/three@0.161.0/build/three.min.js'].filter(Boolean);
      const fgSrcs=[window.VLX_3D_FG_SRC,
        'https://cdn.jsdelivr.net/npm/3d-force-graph@1.73.3/dist/3d-force-graph.min.js','https://unpkg.com/3d-force-graph@1.73.3/dist/3d-force-graph.min.js'].filter(Boolean);

      if(!window.THREE) await ensureLibOnceMulti('THREE', threeSrcs);
      const FG=await ensureLibOnceMulti('ForceGraph3D', fgSrcs);

      const data=await buildGraphDataVLX(word, lemmaLang); root.innerHTML=''; if(root.clientHeight<120) root.style.height='360px';

      const GROUP_COLORS={center:0x7aa2ff,synonyms:0x22c55e,default:0x60a5fa};
      const hex=c=>'#'+c.toString(16).padStart(6,'0');

      const fg=FG({rendererConfig:{preserveDrawingBuffer:true,antialias:true,alpha:true}})(root)
        .nodeId('id').backgroundColor('#0b0f17').nodeRelSize(6).linkOpacity(0.35).linkWidth(0.6)
        .warmupTicks(60).cooldownTime(6500).onNodeDragEnd(n=>{n.fx=n.x;n.fy=n.y;n.fz=n.z;})
        .nodeColor(n=>hex(GROUP_COLORS[n.group]??GROUP_COLORS.default))
        .linkColor(()=>hex(GROUP_COLORS.synonyms))
        .onNodeClick(n=>{ const dist=90, r=1+dist/Math.hypot(n.x||1,n.y||1,n.z||1);
          fg.cameraPosition({x:(n.x||0)*r,y:(n.y||0)*r,z:(n.z||0)*r}, n, 800); $('vlx-q').value=n.id; run(); });

      fg.graphData(data);
      const linkF=fg.d3Force('link');
      linkF.distance(l=>{ const s=(typeof l.source==='object')?l.source:fg.graphData().nodes.find(n=>n.id===l.source);
        const t=(typeof l.target==='object')?l.target:fg.graphData().nodes.find(n=>n.id===l.target);
        return (s?.group==='center'||t?.group==='center')?60:90; });
      fg.d3Force('charge').strength(-180);
      let fitOnce=false; fg.onEngineStop(()=>{ if(!fitOnce){ fitOnce=true; fg.zoomToFit(600,60); } });

      const size=()=>{ fg.width(root.clientWidth).height(root.clientHeight); }; size(); addEventListener('resize', size);

      if(data._empty){
        show3DNotice(root,{ text:'No related words available.' , onRetry:()=>mountThesaurus3D({container,word,lemmaLang})});
      }else{
        const wrap=root.querySelector('.vlx-hintwrap'); if(wrap) wrap.innerHTML='';
      }
    }catch(e){
      show3DNotice(document.querySelector(container), {text:'3D library blocked by CSP/CDN', onRetry:()=>mountThesaurus3D({container,word,lemmaLang})});
    }finally{ document.querySelector(container)?.classList.remove('loading'); }
  }

  // ---------- Images refine ----------
  async function refineImages(raw, imgs, graph, lemmaLang){
    const mode=(imgs?.mode||'').toLowerCase();
    const isAi = /^ai(?:-|_)/.test(mode);
    const hasImgs = (Array.isArray(imgs?.imageUrls)&&imgs.imageUrls.length) || (Array.isArray(imgs?.images)&&imgs.images.length);
    if(isAi || hasImgs) return {imgs, refined:false, phrase:imgs?.base||null};

    // 영어 pivot 후보(그래프 이웃 하나)
    const n = (graph?.vectorNeighbors||[])[0]?.label || String(raw);
    const phrase = /^[a-z]/i.test(n) ? `${n} photo` : String(raw);
    const retry=await getVLImages(phrase,{source:'commons'});
    if((retry?.imageUrls?.length)||(retry?.images?.length)) return {imgs:retry, refined:true, phrase};
    return {imgs, refined:false, phrase:null};
  }

  // ---------- UI Helpers ----------
  function moveTranslateSectionUnderImages(){
    const sec = document.getElementById('sec-trans');
    const imgsWrap = document.getElementById('vlx-imgs')?.parentElement;
    if(sec && imgsWrap && sec.previousElementSibling !== imgsWrap){
      imgsWrap.insertAdjacentElement('afterend', sec);
    }
  }
  const PLAN_URL = 'https://www.visuallexicon.org/subscription';
  function quotaMessage(lang){
    const L = canonLang(lang||'en');
    if (L==='ko') return `AnySearch 이미지 미리보기는 <strong>플랜별 할당량</strong>이 적용됩니다. 사용하려면 <a href="${PLAN_URL}" target="_blank" rel="noopener">구독</a>이 필요합니다.`;
    if (L==='ja') return `AnySearch の画像プレビューにはプランごとの <strong>クォータ</strong>が適用されます。ご利用には<a href="${PLAN_URL}" target="_blank" rel="noopener">サブスクリプション</a>が必要です。`;
    if (L==='zh' || L==='zh-hans') return `AnySearch 图片预览受 <strong>套餐配额</strong>限制。使用需<a href="${PLAN_URL}" target="_blank" rel="noopener">订阅</a>。`;
    if (L==='zh-hant') return `AnySearch 圖片預覽受 <strong>方案額度</strong>限制。使用需<a href="${PLAN_URL}" target="_blank" rel="noopener">訂閱</a>。`;
    return `AnySearch image previews are subject to plan quotas. A <a href="${PLAN_URL}" target="_blank" rel="noopener">subscription</a> is required.`;
  }

  // ---------- Render ----------
  async function renderAll({word, uiLang, aiEN, graph, imgs, refineInfo}){
    const cardEl=$('vlx-card'); cardEl.style.display='block';
    const base=imgs?.base;
    $('vlx-word').textContent=(base&&base!==word)?`${word} (${base})`:word;

    // IPA/Audio (영어 AI가 주는 경우만)
    const ipa = aiEN?.ipa || ''; const audio = aiEN?.audio || '';
    $('vlx-ipa').textContent=ipa?`/${String(ipa).replace(/^\/|\/$/g,'')}/`:''; const audioEl=$('vlx-audio');
    try{audioEl.pause();}catch{} audioEl.removeAttribute('src'); audioEl.load(); audioEl.style.display='none';
    if(audio){ audioEl.src=audio; audioEl.style.display=''; }

    // Images
    const mode=String(imgs?.mode||'');
    const urls=(imgs?.imageUrls || (imgs?.images||[]).map(i=>i.url) || []).slice(0,MAX_IMGS);
    $('vlx-imgs').innerHTML=urls.map(u=>`<div class="vlx-imgbox"><img src="${esc(u)}" loading="lazy" alt="${esc(word)}"></div>`).join('');
    const caption = mode ? `image mode: ${mode}` : '';
    const aiChip = (mode.toLowerCase().startsWith('ai') && base)?` <span class="vlx-tag">AI: ${esc(base)}</span>`:'';
    const refinedChip = (!mode.toLowerCase().startsWith('ai') && refineInfo?.refined && refineInfo.phrase)?` <span class="vlx-tag">refined: ${esc(refineInfo.phrase)}</span>`:'';
    $('vlx-img-caption').innerHTML=(caption?`<span class="vlx-tag">${caption}</span>`:'')+aiChip+refinedChip;
    const qNote = $('vlx-quota'); qNote.innerHTML = quotaMessage(document.documentElement.lang || 'en'); qNote.style.display='inline-flex';

    // Translate panel FIRST (이미지 바로 아래)
    moveTranslateSectionUnderImages();
    mountLangBar(); trans.currentWord=word;
    const lemmaForTrans = (mode.toLowerCase().startsWith('ai') && base) ? base : word;
    renderTranslation(lemmaForTrans);

    // Definitions (영어 AI 요약 — 있으면 1~3개 표시)
    const defs=(aiEN?.definitions || aiEN?.definitionsTranslated || []).slice(0,3);
    $('vlx-defs').innerHTML = defs.length? `<ul class="vlx-list">${defs.map(li).join('')}</ul>` : small('—');
    $('vlx-def-source').innerHTML = aiEN ? 'Source: VLX (AI)' : '';

    // POS
    const pos = (aiEN?.pos && aiEN.pos.length) ? aiEN.pos : guessPOS(word);
    $('vlx-pos').innerHTML = (pos&&pos.length)? pos.map(chip).join('') : small('—');

    // Synonyms / Antonyms (AI)
    const synFromGraph = (graph?.vectorNeighbors||[]).map(n=>n.label);
    const synFromAI = aiEN?.synonyms || aiEN?.syn || [];
    const antFromAI = aiEN?.antonyms || aiEN?.ant || [];
    const syn = uniq([...(synFromAI||[]), ...synFromGraph]).slice(0,18);
    const ant = uniq([...(antFromAI||[]), ...oppositeGuess(word)]).slice(0,16);
    $('vlx-synant').innerHTML =
      (syn.length? `<div><strong>Syn:</strong> ${syn.map(chip).join(' ')}</div>`:'' ) +
      (ant.length? `<div style="margin-top:6px"><strong>Ant:</strong> ${ant.map(chip).join(' ')}</div>`:'' ) || small('—');

    // Derivatives (AI 없으면 규칙 생성)
    const ders = aiEN?.derivatives && aiEN.derivatives.length ? aiEN.derivatives : buildDerivatives(word);
    $('sec-der').style.display = ders.length ? '' : 'none';
    $('vlx-der').innerHTML = ders.length ? ders.map(chip).join('') : '';

    // Examples: 영어 UI에서만
    const isEnUI=canonLang(uiLang)==='en';
    const ex=isEnUI ? (aiEN?.examples || []) : [];
    if(isEnUI && ex.length){ $('sec-ex').style.display=''; $('vlx-ex').innerHTML = `<ul class="vlx-list">${ex.map(li).join('')}</ul>`; }
    else { $('sec-ex').style.display='none'; $('vlx-ex').innerHTML=''; }

    // AI disclaimer
    const aiNote=$('vlx-ai-note');
    aiNote.innerHTML = 'AnySearch uses AI and may occasionally produce incorrect, misleading, or biased results. Please verify important information.';
    aiNote.style.display='inline-flex';

    // 3D graph (VLX only)
    const DISABLE_3D = /(?:[?&#])3d=0\b/i.test(location.href);
    if (!DISABLE_3D) {
      const defer = window.requestIdleCallback || (fn => setTimeout(fn, 0));
      const lemmaLang=guessLang(word);
      defer(() => mountThesaurus3D({container:'#vlx-3d', word, lemmaLang}));
    }
  }

  // ---------- Translate panel ----------
  const trans={ lang:'en', mounted:false };
  function mountLangBar(){
    if(trans.mounted) return;
    const bar=$('vlx-trans-lang');
    bar.innerHTML=LANG_OPTIONS.map(o=>`<button class="vlx-langbtn" data-lang="${o.code}" title="${esc(o.label)}">${esc(o.label)}</button>`).join('');
    bar.addEventListener('click', e=>{
      const btn=e.target.closest('.vlx-langbtn'); if(!btn) return;
      trans.lang=btn.dataset.lang||'en';
      [...bar.querySelectorAll('.vlx-langbtn')].forEach(b=>b.classList.toggle('active', b===btn));
      if(trans.currentWord) renderTranslation(trans.currentWord);
    });
    (bar.querySelector(`[data-lang="${trans.lang}"]`)||bar.querySelector('.vlx-langbtn'))?.classList.add('active');
    trans.mounted=true;
  }
  async function renderTranslation(word){
    const box=$('vlx-trans-body'); box.innerHTML='Loading…';
    try{
      const data=await fetchDefForLang(word, trans.lang) || {};
      const defs=(data?.definitionsTranslated?.length?data.definitionsTranslated:data.definitions)||[];
      const t=data.translation?`<p style="margin:.25rem 0;font-weight:600">${esc(data.translation)}</p>`:'';
      const au=data.audio?`<audio controls preload="metadata" style="width:100%;margin:.25rem 0" src="${esc(data.audio)}"></audio>`:'';
      const dl=defs.length?`<ul style="padding-left:1rem;margin:.25rem 0">${defs.slice(0,8).map(d=>`<li>${esc(d)}</li>`).join('')}</ul>`:small('No translated definitions.');
      box.innerHTML=t+au+dl;
    }catch{ box.innerHTML=small('Failed to load translation.'); }
  }

  // ---------- Suggestions (disabled) ----------
  function hideSuggestions(){ const s=$('vlx-suggest'); if(s){ s.style.display='none'; s.innerHTML=''; } }

  // ---------- Run pipeline ----------
  async function run(){
    const qEl=$('vlx-q'), statusEl=$('vlx-status'), spinEl=$('vlx-spin'), cardEl=$('vlx-card');
    const raw=qEl.value.trim(); if(!raw) return;
    const uiLang=getUiLang(raw); const lemmaLang=guessLang(raw);
    hideSuggestions(); spinEl.style.display='inline-block'; statusEl.textContent='Searching…'; cardEl.style.display='none';

    // 1) Core
    const imgsP = settleWith(getVLImages(raw, decideImageOpts()), 2500, null);
    const aiEnP = settleWith(fetchDefForLang(raw, 'en'),           3000, null);
    const graphP= settleWith(getVLGraph(raw, lemmaLang),           2500, {});

    let [imgs, aiEN, graph] = await Promise.all([imgsP, aiEnP, graphP]);
    imgs = imgs || {}; aiEN = aiEN || {}; graph = graph || {};

    // 2) Image refine (commons retry)
    if(IMG_MODE==='auto'){
      const hasImgs = (Array.isArray(imgs?.imageUrls)&&imgs.imageUrls.length) || (Array.isArray(imgs?.images)&&imgs.images.length);
      if(!hasImgs){ try{ const retry=await settleWith(getVLImages(raw,{source:'commons'}), 1800, null); if((retry?.imageUrls?.length)||(retry?.images?.length)) imgs=retry; }catch{} }
    }
    const refineInfo=await refineImages(raw, imgs, graph, lemmaLang); imgs=refineInfo.imgs;

    if((!imgs?.imageUrls?.length) && (!aiEN || (!aiEN.definitions && !aiEN.translation))){
      statusEl.innerHTML='No content returned. If this site is on a different domain than <code>api.visuallexicon.org</code>, cookies may be blocked. Use a same-origin proxy (<code>window.VLX_PROXY</code>) or set <code>window.VLX_TOKEN</code>.';
    }else statusEl.textContent='';

    spinEl.style.display='none';
    renderAll({word:raw, uiLang, aiEN, graph, imgs, refineInfo});
  }

  // ---------- Events ----------
  $('vlx-go')?.addEventListener('click', e=>{ e.preventDefault(); run(); });
  $('vlx-q')?.addEventListener('keydown', e=>{ if(e.key==='Enter'){ e.preventDefault(); hideSuggestions(); run(); } else if(e.key==='Escape'){ hideSuggestions(); } });
  if(AUTO_SEARCH_ON_INPUT){ $('vlx-q')?.addEventListener('input', debounce(()=>{ const v=$('vlx-q').value.trim(); if(v.length>=2) run(); },600)); }

})();
</script>
